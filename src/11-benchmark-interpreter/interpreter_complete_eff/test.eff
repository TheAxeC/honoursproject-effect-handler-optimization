(* effect Add : (int * int) -> int;;
effect Sub : (int * int) -> int;;
effect Mult : (int * int) -> int;;
effect Div : (int * int) -> int;;

let addHandler = handler
    | #Add (i1,i2) k -> k (i1 + i2)
    | #Sub (i1,i2) k -> k (i1 - i2)
    | #Mult (i1,i2) k -> k (i1 * i2)
    | #Div (i1,i2) k -> k (i1 / i2)

let varHandler x = handler
    | val y -> (fun _ -> y)
    | #Lookup () k -> (fun s -> k s s)
    | #Update s' k -> (fun _ -> k () s')
    | finally f -> f x

;;

with varHandler 0 handle (
    with addHandler handle (
        let a = #Add (1, #Mult (2, 2)) in
        let _ = #Update 3 in
        #Mult (a, #Lookup ())
    )
);; *)

(* type term =
    | Num of int
    | Hand of handle;; *)
type term =
    | Int of int
    | Float of float ;;

effect Num : float -> float;;
effect Add : (float * float) -> float;;
effect Div : (float * float) -> float;;

effect Var : string -> float;;
effect Set : (string * float) -> float;;
effect VarNotFound : unit -> empty;;

effect Func : float -> float;;

let interpHandler = handler
    | #Num i k -> k i
    | #Add (i1, i2) k -> k (i1 +. i2)
    | #Div (i1, i2) k ->
        begin match i2 with
            | 0. -> absurd (#DivisionByZero ())
            | _ -> k (i1 /. i2)
        end;;

let rec lookup x = function
    | [] -> absurd (#VarNotFound ())
    | (x', y) :: lst -> if x = x' then y else lookup x lst;;

let update k v env=
    (k, v) :: env;;

let varHandler = handler
    | val y -> (fun _ -> y)
    | #Var x k -> (fun s -> k (lookup x s) s)
    | #Set (x, y) k -> (fun s -> k y (update x y s));;

(* let funcHandler = handler
    | #Func i k -> (fun f -> k f i) *)

let interpC t =
    with interpHandler handle (t ());;
(*
interpC (#Add ((#Num 1), (#Num 2))) ;; *)

(* let f a = #Func (#Num a);; *)

(* with funcHandler handle (
    with interpHandler handle (
        f 5.
    )
);; *)



interpC (fun () -> #Add ((#Num 1.), (#Num 2.)) );;

interpC (fun () -> #Div ((#Num 1.), (#Num 0.)) ) ;;


let a = (with varHandler handle (#Var "a")) [("a",3.)] ;;
